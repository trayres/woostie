* Command pattern
  The idea is that we encapsulate user actions into this object - all of the data we need to execute those actions is maintained in one place, and is accessible through two commands: do, and undo.
  Because they all derive from a common ancestor (Node), we can generate them and execute them, then place them in the right "place" (i.e. - we add them to the DoStack or RedoStack, based on what the user is trying to do).
  Thus the "Controller" initiates all actions "really" - i.e. it is the one calling do() for each action, and placing them in the right location.

  As an example, nodes are moved "live" - how does this match up to a single cohesive action? Well, it's like a path function - does the user want to undo every single pixel of movement, or only move to the last location? Exactly - they don't. So the state emits a "move" signal once it is DONE dragging, and THIS is stored in a command - but because the object is already moved, it doesn't need to be executed. HOWEVER, if the user undoes then REDOES that action, then the ABILITY to do and undo that command comes into play!

  The interesting thing about this is that it could all be done direclty via the Controller node, but the 'extra step' of encapsulating the action into two functions greatly reduces the complexity of the undo/redo action. It's...almost counter-intuitive. 

  There's quite a bit of weaving here, but I think I see how it can be put together. 

* Undo/Redo
  I added a simple undo/redo by encapsulating the actions with the command pattern and adding a pair of stacks. There was an edge case where if you undid the action of adding a state, it would be freed, then if you redid it the state would be recreated - but it was an incorrect reference when you redid the MOVE command (create state, move, undo, undo, redo, redo would error). I got around that in the MoveStateCommand by simply searching through the stack for the correct reference at do/undo time. That appears to be working.

* Current Direction
  We need to replace the MK1 transition object added on build with the MK2 transition object, and then determine what is missing. It's quite a lot - the CubicBezier_MK0 actually did a bit, but didn't make proper use of signals and architecture.
  Originally the idea was to mock up the instantiation of the transition object via the command pattern, but the command pattern has a reference to the controller (so that we can hook up the signals from the created transition object!)
  So rather than doing it as a mockup, I'll just inject the CubicBezier_MK2 directly into the Woostie project, and debug live as we go.

* TODO:
  I need to change the emission of the signal when you break a transition anchor away from a state
  so that it's properly handled by the controller - this will allow the controller to do some of the stuff the kineticstate is doing, which will improve the overall readability. Currently the KineticState has some "funky" handling that 'reaches into' the transition anchor - it's ugly, but if we redirect to the controller, then have the controller do the disconnect logic, then we can simplify the kinetic state.
  

* Attributes
  I really like the attribute notation in Fizzim, but it doesn't always make sense. Like you're showing the TYPE column to the user, for the machine's NAME. What are the options? I don't know without digging into the...Perl? No, no. Just no, thank you.
  The same goes for the UserAtts column - I understand that it's for extending the backend, but you show it even if it's empty. The "ResetValue" column is shown - why would the machine's name change on Reset?

  This means the user has to hold in their head the fields that can/should be changed for use - it implies a hidden "mask" on the data (like an overlay which indicates what fields should be used). That doesn't seem great from a UI perspective.

* The "Setup" page, and the setup function
  So I've been using a function (called "setup") for various UI elements; this allows me to call one function on the scene to get it ready before being called. This seems to be working well - here's an example. I could pass a reference to the list of states and their names to the Setup page, in a simple array.
  OR I could pass a reference to the States node, and make the UI layer extract the names. But that means if I want to mock this thing up for testing, I could either pass in a simple array of strings, or I could pass an honest-to-god reference to the a State object. One of these is much easier, faster, and allows for better decoupling - obviously the simple string array.

  Pretty neat. 
