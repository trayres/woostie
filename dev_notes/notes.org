* Command pattern
  The idea is that we encapsulate user actions into this object - all of the data we need to execute those actions is maintained in one place, and is accessible through two commands: do, and undo.
  Because they all derive from a common ancestor (Node), we can generate them and execute them, then place them in the right "place" (i.e. - we add them to the DoStack or RedoStack, based on what the user is trying to do).
  Thus the "Controller" initiates all actions "really" - i.e. it is the one calling do() for each action, and placing them in the right location.

  As an example, nodes are moved "live" - how does this match up to a single cohesive action? Well, it's like a path function - does the user want to undo every single pixel of movement, or only move to the last location? Exactly - they don't. So the state emits a "move" signal once it is DONE dragging, and THIS is stored in a command - but because the object is already moved, it doesn't need to be executed. HOWEVER, if the user undoes then REDOES that action, then the ABILITY to do and undo that command comes into play!

  The interesting thing about this is that it could all be done direclty via the Controller node, but the 'extra step' of encapsulating the action into two functions greatly reduces the complexity of the undo/redo action. It's...almost counter-intuitive. 

  There's quite a bit of weaving here, but I think I see how it can be put together. 

* Undo/Redo
  I added a simple undo/redo by encapsulating the actions with the command pattern and adding a pair of stacks. There was an edge case where if you undid the action of adding a state, it would be freed, then if you redid it the state would be recreated - but it was an incorrect reference when you redid the MOVE command (create state, move, undo, undo, redo, redo would error). I got around that in the MoveStateCommand by simply searching through the stack for the correct reference at do/undo time. That appears to be working.

* Current Direction
  We need to replace the MK1 transition object added on build with the MK2 transition object, and then determine what is missing. It's quite a lot - the CubicBezier_MK0 actually did a bit, but didn't make proper use of signals and architecture.
  Originally the idea was to mock up the instantiation of the transition object via the command pattern, but the command pattern has a reference to the controller (so that we can hook up the signals from the created transition object!)
  So rather than doing it as a mockup, I'll just inject the CubicBezier_MK2 directly into the Woostie project, and debug live as we go.

* TODO:
  I need to change the emission of the signal when you break a transition anchor away from a state
  so that it's properly handled by the controller - this will allow the controller to do some of the stuff the kineticstate is doing, which will improve the overall readability. Currently the KineticState has some "funky" handling that 'reaches into' the transition anchor - it's ugly, but if we redirect to the controller, then have the controller do the disconnect logic, then we can simplify the kinetic state.
