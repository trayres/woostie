* Command pattern
  The idea is that we encapsulate user actions into this object - all of the data we need to execute those actions is maintained in one place, and is accessible through two commands: do, and undo.
  Because they all derive from a common ancestor (Node), we can generate them and execute them, then place them in the right "place" (i.e. - we add them to the DoStack or RedoStack, based on what the user is trying to do).
  Thus the "Controller" initiates all actions "really" - i.e. it is the one calling do() for each action, and placing them in the right location.

  As an example, nodes are moved "live" - how does this match up to a single cohesive action? Well, it's like a path function - does the user want to undo every single pixel of movement, or only move to the last location? Exactly - they don't. So the state emits a "move" signal once it is DONE dragging, and THIS is stored in a command - but because the object is already moved, it doesn't need to be executed. HOWEVER, if the user undoes then REDOES that action, then the ABILITY to do and undo that command comes into play!

  The interesting thing about this is that it could all be done direclty via the Controller node, but the 'extra step' of encapsulating the action into two functions greatly reduces the complexity of the undo/redo action. It's...almost counter-intuitive. 

  There's quite a bit of weaving here, but I think I see how it can be put together. 

* Undo/Redo
  I added a simple undo/redo by encapsulating the actions with the command pattern and adding a pair of stacks. There was an edge case where if you undid the action of adding a state, it would be freed, then if you redid it the state would be recreated - but it was an incorrect reference when you redid the MOVE command (create state, move, undo, undo, redo, redo would error). I got around that in the MoveStateCommand by simply searching through the stack for the correct reference at do/undo time. That appears to be working.

* Current Direction
  We need to replace the MK1 transition object added on build with the MK2 transition object, and then determine what is missing. It's quite a lot - the CubicBezier_MK0 actually did a bit, but didn't make proper use of signals and architecture.
  Originally the idea was to mock up the instantiation of the transition object via the command pattern, but the command pattern has a reference to the controller (so that we can hook up the signals from the created transition object!)
  So rather than doing it as a mockup, I'll just inject the CubicBezier_MK2 directly into the Woostie project, and debug live as we go.

* TODO:
  I need to change the emission of the signal when you break a transition anchor away from a state
  so that it's properly handled by the controller - this will allow the controller to do some of the stuff the kineticstate is doing, which will improve the overall readability. Currently the KineticState has some "funky" handling that 'reaches into' the transition anchor - it's ugly, but if we redirect to the controller, then have the controller do the disconnect logic, then we can simplify the kinetic state.
  

* Attributes
  I really like the attribute notation in Fizzim, but it doesn't always make sense. Like you're showing the TYPE column to the user, for the machine's NAME. What are the options? I don't know without digging into the...Perl? No, no. Just no, thank you.
  The same goes for the UserAtts column - I understand that it's for extending the backend, but you show it even if it's empty. The "ResetValue" column is shown - why would the machine's name change on Reset?

  This means the user has to hold in their head the fields that can/should be changed for use - it implies a hidden "mask" on the data (like an overlay which indicates what fields should be used). That doesn't seem great from a UI perspective.

* The "Setup" page, and the setup function
  So I've been using a function (called "setup") for various UI elements; this allows me to call one function on the scene to get it ready before being called. This seems to be working well - here's an example. I could pass a reference to the list of states and their names to the Setup page, in a simple array.
  OR I could pass a reference to the States node, and make the UI layer extract the names. But that means if I want to mock this thing up for testing, I could either pass in a simple array of strings, or I could pass an honest-to-god reference to the a State object. One of these is much easier, faster, and allows for better decoupling - obviously the simple string array.

  Pretty neat. 

* Data Objects
  Basically I needed something like a struct; to get better encapsulation, when developing e.g. the Setup scene, you don't want to pass a reference to the current list of states within the controller - you can't isolate and test that.
  You could pass in arrays with things like the name and indexes, but what if the user does something like change the name of the clock pin? Or changes the name of a state? Etc.
  What if a user says that they have inputs:
  A, B, CLK, C
  And we use input indexes, then they delete input B?
  A,CLK,C

  I think we can still use the index number, but on deletion, we need to remove any references to the deleted input index. So if the user sets input B as the clock, then deletes B, the Clock input will be undefined - the user should have to reset it (however, that shouldn't happen when the user changes the name - if they mistype "Clock" as "Clook", then fixes it, the index should still be valid.

  I guess then we should have a list of inputs, and the inputs themselves have an index, and the index is built inside the setup page and then passed back out (either to the controller or to the global singleton).
  Ok so the plan of attack is to create DataObjects (simplified classes) that are created right before the Setup page pops up (so they are never stale), and only the relevant information in them that changes anything in the controller is passed to it (e.g. the machine's name changes, that change should persist, clearly.)

* Current Code Location
  Currently I'm trying to extract everything I need in the "Setup" scene. Basically I'm trying to "collapse" what I need into DataObjects. When the code generator is launched, it will (effectively) SCRAPE DataObjects from the Controller node, and then process them to create the generated RTL.
  This allows us to mock up an entire code-generation run with FAKE DataObjects, and exercise both the Setup scene as well as the code generator, so they can all be tested independently.
  Later improvements can be made, but I think this is a good time to "firm up" the API. 
